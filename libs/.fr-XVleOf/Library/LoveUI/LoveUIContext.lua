-- LoveUIContext.lua
-- Usually only one of these instances in a love app. The first one is auto-generated by LoveUI.
-- contains content views

-- A Context contains a contentView, which holds an array of subviews to be displayed on the screen. These views also receive mouse and key events directed to them from the Context.

LoveUI.require("LoveUIStack.lua")
LoveUI.require("LoveUIGraphicsEnvironment.lua")
LoveUI.require("LoveUIEvent.lua")
LoveUI.require("LoveUIRect.lua")
LoveUI.require("LoveUIResponder.lua")
LoveUI.require("LoveUIView.lua")
LoveUI.Context=LoveUI.Responder:new();

function LoveUI.Context:init()
	-- e.g local o=LoveUI.Object:alloc():init();
	LoveUI.Responder.init(self);
	self.eventNumber=0;
	self.doubleClickSpeed=300;
		--two clicks at same spot within 300 ms is double click. 
	self.keyRepeatSpeed=300;
		--key held for 300 milis is repeat key.
	self.lastMouseEvent=nil;
	self.lastKeyEvent=nil;
	self.keysDown={};
	
	
	self.clickCount=1;
	self.contentView=LoveUI.View:new(LoveUI.Rect:new(0,0,LoveUI.graphics.getWidth(), LoveUI.graphics.getHeight()));
	self.contentView.context=self;
	self.contentView.opaque=false;
	self.firstResponder=self.contentView;
	self.graphicsEnvironmentStack=LoveUI.Stack:new();
	return self;
end


function LoveUI.Context:setFirstResponder(aResponder)
	if self.firstResponder:resignFirstResponder() then
		if aResponder:acceptsFirstResponder() then
		
			if aResponder:becomeFirstResponder() then
				
				self.firstResponder=aResponder
				return true
			end
		end
	end
	return false
end

function LoveUI.Context:plugin()
	-- e.g myContext:plugin()
	-- cannot be undone, useful when have a persistant context
	local oldmp=mousepressed;
	mousepressed=function(x, y, button, ...)
		self:mouseEvent(x, y, button, self.mouseDown)
		if type(oldmp)=="function" then
			return oldmp(x, y, button, ...)
		end
	end
	local oldmr=mousereleased;
	mousereleased=function(x, y, button, ...)
		self:mouseEvent(x, y, button, self.mouseUp)
		if type(oldmr)=="function" then
			return oldmr(x, y, button, ...)
		end
	end
	local oldkp=keypressed;
	keypressed=function(key, ...)
		self:keyEvent(key, self.keyDown)
		if type(oldkp)=="function" then
			return oldkp(key, ...)
		end
	end
	local oldkr=keyreleased;
	keyreleased=function(key, ...)
		self:keyEvent(key, self.keyUp)
		if type(oldkr)=="function" then
			return oldkr(key, ...)
		end
	end
	local olddraw=draw;
	draw=function(...)
		self:display()
		
		if type(olddraw)=="function" then
			return olddraw(...)
		end
	end
	local oldupdate=update;
	update=function(dt, ...)
		self:update(dt);
		if type(oldupdate)=="function" then
			return oldupdate(dt, ...)
		end
	end
end
function LoveUI.Context:update(dt)
	self:checkKeyRepeat();
	--self.contentView:update(dt);
	--self.contentView:updateSubviews(dt);
	LoveUI.pushMatrix()
	LoveUI.translate(self.firstResponder.frame.origin:get())
	self.firstResponder:update(dt);
	self.firstResponder:updateSubviews(dt);
	LoveUI.popMatrix()
end
function LoveUI.Context:keyEvent(key, call)
	-- to be plugged into mousepressed call back function
	local mouseLocation=LoveUI.Point:new(love.mouse.getX(), love.mouse.getY());
	local timestamp=LoveUI.time()
	local context=self
	
		local keysDown={}
		for k, v in pairs(self.keysDown) do
			keysDown[k]=v;
		end
		
	local theEvent=LoveUI.Event:keyEvent(mouseLocation, key, keysDown, timestamp, context, 1);
	call(self, theEvent)
	self.lastKeyEvent=theEvent;
end

function LoveUI.Context:checkKeyRepeat()
	if self.lastKeyEvent== nil then
		return nil;
	end
	if not love.keyboard.isDown(self.lastKeyEvent.keyCode) then
		return nil;
	end
	local timestamp=LoveUI.time()
	if timestamp-self.lastKeyEvent.timestamp >=self.keyRepeatSpeed then
			self:keyEvent(self.lastKeyEvent.keyCode, self.keyDown);
			self.keyRepeatSpeed=math.max(self.keyRepeatSpeed*0.5, 50);
	end
end

function LoveUI.Context:keyUp(theEvent)
	self.keyRepeatSpeed=300;
	for k, v in pairs(self.keysDown) do
		if v==theEvent.keyCode then
			table.remove(self.keysDown, k)
			break;
		end
	end
	if self.lastKeyEvent~=nil and theEvent.keyCode==self.lastKeyEvent.keyCode then
		self.lastKeyEvent=nil;
	end
	if self.firstResponder~=nil then
		self.firstResponder:keyUp(theEvent);
	end
end

function LoveUI.Context:keyDown(theEvent)
	local keysDownHasKey=false;
	for k, v in pairs(self.keysDown) do
		if v==theEvent.keyCode then
			keysDownHasKey=true;
			break;
		end
	end
	if keysDownHasKey==false then
		table.insert(self.keysDown, theEvent.keyCode);
	end
	self.lastKeyEvent=theEvent;
	if self.firstResponder~=nil then
		self.firstResponder:keyDown(theEvent);
	end
end

function LoveUI.Context:mouseEvent(x, y, button, call)
	-- to be plugged into mousepressed call back function
	local location=LoveUI.Point:new(x, y);
	local timestamp=LoveUI.time()
	local context=self
	local eventNumber=context.eventNumber
	if self.lastMouseEvent~=nil then
		if timestamp-self.lastMouseEvent.timestamp <= self.doubleClickSpeed
			and self.lastMouseEvent.button==button and self.lastMouseEvent.mouseLocation:isEqual(location) then
			self.clickCount=self.clickCount+1;
		else
			self.clickCount=1;
		end
	end
		local keysDown={}
		for k, v in pairs(self.keysDown) do
			keysDown[k]=v;
		end
	local theEvent=LoveUI.Event:mouseEvent(location, button, keysDown, timestamp, context, eventNumber, clickCount);
	call(self, theEvent)
	
	self.lastMouseEvent=theEvent;
	context.eventNumber=context.eventNumber+1
end


function LoveUI.Context:reclick()
	if self.lastMouseEvent~=nil then
		self:mouseEvent(self.lastMouseEvent.mouseLocation.x, self.lastMouseEvent.mouseLocation.y, self.lastMouseEvent.button, self.mouseDown);
	else
		self:mouseEvent(love.mouse.getX(), love.mouse.getY(), 1, self.mouseDown);	
	end
end

function LoveUI.Context:setContentView(view)
	view:setNextResponder(self)
	self.contentView=view;
	if self.firstResponder==nil then
		self:setFirstResponder(self.contentView)
	end
end

function LoveUI.Context:storeGraphicsEnvironment()
	local genv=LoveUI.GraphicsEnvironment:new()
	self.graphicsEnvironmentStack:push(genv)
end

function LoveUI.Context:restoreGraphicsEnvironment()
	local genv=self.graphicsEnvironmentStack:pop();
	genv:restore();
end

function LoveUI.Context:setScissorFrame(frame)
	LoveUI.graphics.setScissor(frame.origin.x, frame.origin.y, math.min(frame.size.width, w or frame.size.width), math.min(frame.size.height, h or frame.size.height));
end

function LoveUI.Context:display(dt)
	self:storeGraphicsEnvironment()
	
	self.contentView:display(dt);
	self.contentView:displaySubviews(dt);
	
	self:restoreGraphicsEnvironment()
end

function LoveUI.Context:addSubview(...)
	self.contentView:addSubview(...)
end

function LoveUI.Context:mouseDown(theEvent)
	local aView=self.firstResponder;
	if self.firstResponder:resignFirstResponder() then
		aView=self.contentView;
	end
	-- Now, find the front most view that is being hit by mouse.
	while aView~=nil do
		local subviews=aView.subviews;
		local viewmatched=false;
		if #subviews==0 then break end
		for k, v in pairs(subviews) do
			v=subviews[#subviews-k+1];
			if not v.hidden then
				if LoveUI.mouseInRect(theEvent.mouseLocation, self.contentView:convertRectFromView(v.frame, aView)) then
					-- theEvent's location is in contentView's coordinate system
					
					aView=v;
					aView:bringToFront();
					viewmatched=true;
					break;
				end
			end
		end
		if viewmatched==false then
			break
		end
	end
	
	if aView==nil then
		aView=self.contentView;
	end
	
	if self.firstResponder:resignFirstResponder() then
		if self:setFirstResponder(aView) then
			-- Forward thEvent to the responder
			aView:mouseDown(theEvent);
		end
	else
		self.firstResponder:mouseDown(theEvent);
	end
	
end

function LoveUI.Context:mouseUp(theEvent)
	if self.firstResponder~=nil then
		-- Forward thEvent to the responder
		self.firstResponder:mouseUp(theEvent)
		--if self.firstResponder:resignFirstResponder() then
			--self.firstResponder=self.contentView;
		--end
	end
end
